# FreelanceHub Backend - Complete Production-Ready Development Guide

## Project Overview
Build a comprehensive, production-ready NestJS backend for FreelanceHub, a Sri Lankan freelancer hiring platform with **Stripe payments** and **WebAuthn Passkey authentication**. This system must handle real money transactions, user verification, and complex business workflows.

## Technology Stack & Architecture

### Core Stack
- **Backend**: NestJS with TypeScript, class-validator, class-transformer
- **Database**: MongoDB with Mongoose ODM
- **Authentication**: WebAuthn (Passkeys) + TOTP 2FA
- **Payments**: Stripe API with webhooks
- **Storage**: AWS S3 / Google Cloud Storage
- **Real-time**: Socket.IO for messaging/notifications
- **Caching**: Redis for sessions, rate limiting, search caching
- **Email**: SendGrid / AWS SES for transactional emails
- **Monitoring**: Winston logging, Prometheus metrics
- **Containerization**: Docker with multi-stage builds

### System Architecture
```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Load Balancer │────│   NestJS API     │────│   MongoDB       │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                                │                         │
                       ┌──────────────────┐    ┌─────────────────┐
                       │   Redis Cache    │    │   File Storage  │
                       └──────────────────┘    └─────────────────┘
                                │
                       ┌──────────────────┐    ┌─────────────────┐
                       │   Stripe API     │    │   Email Service │
                       └──────────────────┘    └─────────────────┘
```

## Complete Database Schema with Validation

### 1. User Schema
```typescript
@Schema({ timestamps: true })
export class User {
  @Prop({ required: true, unique: true, lowercase: true })
  @IsEmail()
  email: string;

  @Prop({ required: true, unique: true, minlength: 3, maxlength: 50 })
  @Matches(/^[a-zA-Z0-9_-]+$/)
  username: string;

  @Prop({ type: [String], enum: ['freelancer', 'client'], required: true })
  roles: UserRole[];

  @Prop({ type: ProfileSchema, required: true })
  profile: Profile;

  @Prop({ type: VerificationSchema })
  verification: Verification;

  @Prop({ type: [PasskeySchema] })
  passkeys: PasskeyCredential[];

  @Prop({ type: TwoFactorAuthSchema })
  twoFactorAuth?: TwoFactorAuth;

  @Prop({ type: PreferencesSchema })
  preferences: UserPreferences;

  @Prop({ type: ActivitySchema })
  activity: UserActivity;

  @Prop({ enum: ['active', 'suspended', 'deactivated'], default: 'active' })
  status: UserStatus;

  @Prop({ default: Date.now })
  lastPasswordReset?: Date;

  @Prop({ type: [String] })
  refreshTokens: string[];
}

// Embedded schemas
const ProfileSchema = new Schema({
  firstName: { type: String, required: true, maxlength: 50 },
  lastName: { type: String, required: true, maxlength: 50 },
  avatar: { type: String, validate: /^https?:\/\// },
  phone: { type: String, validate: /^\+[1-9]\d{1,14}$/ },
  dateOfBirth: { type: Date },
  location: {
    country: { type: String, required: true },
    city: { type: String, required: true },
    coordinates: { type: [Number], index: '2dsphere' }
  }
});

const PasskeySchema = new Schema({
  credentialId: { type: String, required: true, unique: true },
  publicKey: { type: String, required: true },
  counter: { type: Number, default: 0 },
  deviceType: { type: String, required: true },
  name: { type: String, required: true }, // user-given name
  createdAt: { type: Date, default: Date.now },
  lastUsed: Date
});
```

### 2. FreelancerProfile Schema
```typescript
@Schema({ timestamps: true })
export class FreelancerProfile {
  @Prop({ type: Schema.Types.ObjectId, ref: 'User', required: true, unique: true })
  userId: ObjectId;

  @Prop({ type: ProfessionalSchema, required: true })
  professional: Professional;

  @Prop({ type: SkillsSchema, required: true })
  skills: Skills;

  @Prop({ type: [PortfolioItemSchema] })
  portfolio: PortfolioItem[];

  @Prop({ type: PricingSchema })
  pricing: Pricing;

  @Prop({ type: [EducationSchema] })
  education: Education[];

  @Prop({ type: [CertificationSchema] })
  certifications: Certification[];

  @Prop({ type: [LanguageSchema], required: true })
  languages: Language[];

  @Prop({ type: StatsSchema })
  stats: FreelancerStats;

  @Prop({ type: VisibilitySchema })
  visibility: Visibility;

  @Prop({ default: 100 })
  @Min(0) @Max(100)
  completionPercentage: number;
}

const ProfessionalSchema = new Schema({
  title: { type: String, required: true, maxlength: 100 },
  description: { type: String, required: true, maxlength: 2000 },
  experience: { type: String, enum: ['entry', 'intermediate', 'expert'], required: true },
  availability: { type: String, enum: ['available', 'busy', 'unavailable'], default: 'available' },
  workingHours: {
    timezone: { type: String, required: true },
    schedule: {
      monday: { start: String, end: String, available: Boolean },
      tuesday: { start: String, end: String, available: Boolean },
      wednesday: { start: String, end: String, available: Boolean },
      thursday: { start: String, end: String, available: Boolean },
      friday: { start: String, end: String, available: Boolean },
      saturday: { start: String, end: String, available: Boolean },
      sunday: { start: String, end: String, available: Boolean }
    }
  }
});

const PricingSchema = new Schema({
  hourlyRate: {
    min: { type: Number, min: 1, max: 10000 },
    max: { type: Number, min: 1, max: 10000 },
    currency: { type: String, default: 'USD', enum: ['USD', 'LKR'] }
  },
  fixedPricePackages: [{
    title: { type: String, required: true, maxlength: 100 },
    description: { type: String, required: true, maxlength: 500 },
    price: { type: Number, required: true, min: 1 },
    deliveryDays: { type: Number, required: true, min: 1, max: 365 },
    revisions: { type: Number, min: 0, max: 10 }
  }]
});
```

### 3. Project Schema with Complex Validation
```typescript
@Schema({ timestamps: true })
export class Project {
  @Prop({ type: Schema.Types.ObjectId, ref: 'User', required: true })
  clientId: ObjectId;

  @Prop({ required: true, maxlength: 150 })
  title: string;

  @Prop({ required: true, minlength: 100, maxlength: 5000 })
  description: string;

  @Prop({ required: true })
  category: string;

  @Prop()
  subcategory: string;

  @Prop({ type: [String], required: true, validate: [(val) => val.length > 0, 'At least one skill required'] })
  requiredSkills: string[];

  @Prop({ enum: ['fixed', 'hourly'], required: true })
  type: ProjectType;

  @Prop({ type: BudgetSchema, required: true })
  budget: Budget;

  @Prop({ type: TimelineSchema })
  timeline: Timeline;

  @Prop({ type: [String], validate: [(val) => val.length <= 10, 'Maximum 10 attachments'] })
  attachments: string[];

  @Prop({ enum: ['public', 'private', 'invited'], default: 'public' })
  visibility: ProjectVisibility;

  @Prop({ type: [{ type: Schema.Types.ObjectId, ref: 'User' }] })
  invitedFreelancers: ObjectId[];

  @Prop({ type: ProposalsSchema })
  proposals: ProjectProposals;

  @Prop({ enum: ['draft', 'open', 'in_progress', 'completed', 'cancelled', 'disputed'], default: 'draft' })
  status: ProjectStatus;

  @Prop({ type: Schema.Types.ObjectId, ref: 'User' })
  selectedFreelancer: ObjectId;

  @Prop({ type: Schema.Types.ObjectId, ref: 'Contract' })
  contract: ObjectId;

  @Prop({ default: 0 })
  views: number;

  // Indexes for search performance
  @Prop({ index: 'text' })
  searchText: string; // Combined title + description for full-text search
}

// Pre-save middleware to generate search text
ProjectSchema.pre('save', function() {
  this.searchText = `${this.title} ${this.description}`;
});
```

### 4. Enhanced Contract Schema with State Management
```typescript
@Schema({ timestamps: true })
export class Contract {
  @Prop({ type: Schema.Types.ObjectId, ref: 'Project', required: true, unique: true })
  projectId: ObjectId;

  @Prop({ type: Schema.Types.ObjectId, ref: 'User', required: true })
  clientId: ObjectId;

  @Prop({ type: Schema.Types.ObjectId, ref: 'User', required: true })
  freelancerId: ObjectId;

  @Prop({ type: Schema.Types.ObjectId, ref: 'Proposal', required: true })
  proposalId: ObjectId;

  @Prop({ type: ContractTermsSchema, required: true })
  terms: ContractTerms;

  @Prop({ type: [MilestoneSchema], required: true, validate: [(val) => val.length > 0, 'At least one milestone required'] })
  milestones: Milestone[];

  @Prop({ default: 0 })
  currentMilestone: number;

  @Prop({ type: EscrowSchema })
  escrow: Escrow;

  @Prop({ enum: ['active', 'completed', 'cancelled', 'disputed'], default: 'active' })
  status: ContractStatus;

  @Prop({ default: Date.now })
  startDate: Date;

  @Prop()
  endDate: Date;

  // Contract modifications tracking
  @Prop({ type: [ContractModificationSchema] })
  modifications: ContractModification[];

  // Performance tracking
  @Prop({ type: PerformanceMetricsSchema })
  performanceMetrics: PerformanceMetrics;
}

const MilestoneSchema = new Schema({
  title: { type: String, required: true, maxlength: 100 },
  description: { type: String, required: true, maxlength: 1000 },
  amount: { type: Number, required: true, min: 1 },
  dueDate: Date,
  deliverables: [{ type: String, required: true }],
  status: { 
    type: String, 
    enum: ['pending', 'in_progress', 'submitted', 'approved', 'rejected'],
    default: 'pending'
  },
  submissions: [{
    files: [String],
    notes: { type: String, maxlength: 1000 },
    submittedAt: { type: Date, default: Date.now }
  }],
  feedback: String,
  approvedAt: Date,
  rejectedAt: Date,
  rejectionReason: String
});

const EscrowSchema = new Schema({
  stripePaymentIntentId: String,
  totalEscrowed: { type: Number, default: 0 },
  availableForRelease: { type: Number, default: 0 },
  released: { type: Number, default: 0 },
  refunded: { type: Number, default: 0 },
  platformFeeRate: { type: Number, default: 0.1 }, // 10% platform fee
  stripeFeeRate: { type: Number, default: 0.029 } // 2.9% + $0.30
});
```

### 5. Payment Schema with Stripe Integration
```typescript
@Schema({ timestamps: true })
export class Payment {
  @Prop({ type: Schema.Types.ObjectId, ref: 'Contract', required: true })
  contractId: ObjectId;

  @Prop()
  milestoneIndex: number;

  @Prop({ required: true })
  stripePaymentIntentId: string;

  @Prop()
  stripeChargeId: string;

  @Prop({ required: true, min: 0.01 })
  amount: number;

  @Prop({ enum: ['USD', 'LKR'], default: 'USD' })
  currency: string;

  @Prop({ enum: ['escrow_funding', 'milestone_release', 'refund', 'platform_fee'], required: true })
  type: PaymentType;

  @Prop({ enum: ['pending', 'processing', 'succeeded', 'failed', 'cancelled'], default: 'pending' })
  status: PaymentStatus;

  @Prop({ required: true, min: 0 })
  platformFee: number;

  @Prop({ required: true, min: 0 })
  stripeFee: number;

  @Prop({ required: true, min: 0 })
  freelancerAmount: number;

  @Prop({ type: Schema.Types.Mixed })
  metadata: Record<string, any>;

  @Prop()
  processedAt: Date;

  @Prop()
  failureReason: string;

  // Idempotency key for Stripe operations
  @Prop({ unique: true, sparse: true })
  idempotencyKey: string;
}
```

## Complete API Endpoints with Detailed Specifications

### Authentication Endpoints
```typescript
// Authentication Controller
@Controller('auth')
@UseGuards(RateLimitGuard) // 10 requests per minute
export class AuthController {
  
  @Post('register')
  @ApiOperation({ summary: 'Register new user with email verification' })
  @ApiBody({ type: RegisterUserDto })
  async register(@Body() registerDto: RegisterUserDto): Promise<{ message: string, verificationRequired: boolean }> {
    // 1. Validate email uniqueness
    // 2. Create user with unverified status
    // 3. Send verification email
    // 4. Return success message
  }

  @Post('verify-email')
  @ApiOperation({ summary: 'Verify email address' })
  async verifyEmail(@Body() verifyDto: VerifyEmailDto): Promise<{ success: boolean }> {
    // 1. Validate verification token
    // 2. Mark email as verified
    // 3. Enable account access
  }

  @Post('passkey/registration-challenge')
  @UseGuards(JwtAuthGuard) // User must be logged in
  async getRegistrationChallenge(@Request() req): Promise<PublicKeyCredentialCreationOptions> {
    // 1. Generate WebAuthn registration challenge
    // 2. Store challenge in Redis with expiry
    // 3. Return challenge options
  }

  @Post('passkey/register')
  @UseGuards(JwtAuthGuard)
  async registerPasskey(@Body() passkeyDto: RegisterPasskeyDto): Promise<{ success: boolean }> {
    // 1. Validate registration response
    // 2. Verify challenge
    // 3. Store credential
    // 4. Mark passkey as active
  }

  @Post('login/challenge')
  @ApiOperation({ summary: 'Get WebAuthn authentication challenge' })
  async getAuthenticationChallenge(@Body() loginDto: LoginChallengeDto): Promise<PublicKeyCredentialRequestOptions> {
    // 1. Find user by email/username
    // 2. Generate authentication challenge
    // 3. Return challenge with allowed credentials
  }

  @Post('login/verify')
  @ApiOperation({ summary: 'Verify WebAuthn authentication' })
  async verifyAuthentication(@Body() authDto: VerifyAuthenticationDto): Promise<LoginResponse> {
    // 1. Validate authentication response
    // 2. Verify signature
    // 3. Update credential counter
    // 4. Generate JWT tokens
    // 5. Log successful login
  }

  @Post('2fa/enable')
  @UseGuards(JwtAuthGuard)
  async enable2FA(@Request() req): Promise<{ qrCode: string, backupCodes: string[] }> {
    // 1. Generate TOTP secret
    // 2. Create QR code
    // 3. Generate backup codes
    // 4. Store temporarily (not active until verified)
  }

  @Post('2fa/verify-setup')
  @UseGuards(JwtAuthGuard)
  async verify2FASetup(@Body() verifyDto: Verify2FADto): Promise<{ success: boolean }> {
    // 1. Validate TOTP code
    // 2. Activate 2FA
    // 3. Save backup codes encrypted
  }
}

// DTOs with comprehensive validation
export class RegisterUserDto {
  @IsEmail()
  @Transform(({ value }) => value.toLowerCase())
  email: string;

  @IsString()
  @Length(3, 50)
  @Matches(/^[a-zA-Z0-9_-]+$/)
  username: string;

  @IsString()
  @Length(2, 50)
  firstName: string;

  @IsString()
  @Length(2, 50)
  lastName: string;

  @IsEnum(['freelancer', 'client'])
  primaryRole: UserRole;

  @IsOptional()
  @IsPhoneNumber()
  phone?: string;

  @IsString()
  @Length(2, 100)
  country: string;

  @IsString()
  @Length(2, 100)
  city: string;
}
```

### Project Management with Complex Business Logic
```typescript
@Controller('projects')
@UseGuards(JwtAuthGuard)
export class ProjectController {
  
  @Post()
  @UseGuards(RoleGuard('client'))
  @ApiOperation({ summary: 'Create new project' })
  async createProject(@Body() createDto: CreateProjectDto, @Request() req): Promise<Project> {
    // 1. Validate project data
    // 2. Check client's payment method
    // 3. Calculate estimated platform fees
    // 4. Create project in draft status
    // 5. Upload and validate attachments
    // 6. Return created project
  }

  @Get('search')
  @ApiOperation({ summary: 'Search projects with advanced filters' })
  @ApiQuery({ name: 'query', required: false })
  @ApiQuery({ name: 'category', required: false })
  @ApiQuery({ name: 'skills', required: false, type: [String] })
  @ApiQuery({ name: 'budget_min', required: false, type: Number })
  @ApiQuery({ name: 'budget_max', required: false, type: Number })
  @ApiQuery({ name: 'type', required: false, enum: ['fixed', 'hourly'] })
  @ApiQuery({ name: 'posted_within', required: false, enum: ['1d', '3d', '7d', '30d'] })
  @ApiQuery({ name: 'sort', required: false, enum: ['newest', 'budget_high', 'budget_low', 'relevance'] })
  async searchProjects(@Query() searchDto: SearchProjectsDto): Promise<PaginatedResponse<Project>> {
    // 1. Build MongoDB aggregation pipeline
    // 2. Apply text search if query provided
    // 3. Apply all filters
    // 4. Sort results
    // 5. Add pagination
    // 6. Include client ratings and verification status
    // 7. Track search analytics
  }

  @Get('recommendations')
  @UseGuards(RoleGuard('freelancer'))
  async getRecommendations(@Request() req): Promise<Project[]> {
    // 1. Get freelancer's skills and categories
    // 2. Analyze past project history
    // 3. Consider success rates in different categories
    // 4. Apply ML-based recommendation algorithm
    // 5. Filter by availability and preferences
    // 6. Return ranked recommendations
  }

  @Post(':id/invite')
  @UseGuards(RoleGuard('client'))
  async inviteFreelancers(@Param('id') projectId: string, @Body() inviteDto: InviteFreelancersDto): Promise<{ success: boolean }> {
    // 1. Validate project ownership
    // 2. Check freelancer availability
    // 3. Send invitation notifications
    // 4. Update project invited list
    // 5. Log invitation activity
  }
}

// Advanced search DTO with complex validation
export class SearchProjectsDto {
  @IsOptional()
  @IsString()
  @Length(1, 100)
  query?: string;

  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @IsArray()
  @ArrayMaxSize(10)
  skills?: string[];

  @IsOptional()
  @IsNumber()
  @Min(1)
  budget_min?: number;

  @IsOptional()
  @IsNumber()
  @Min(1)
  budget_max?: number;

  @IsOptional()
  @IsEnum(['fixed', 'hourly'])
  type?: ProjectType;

  @IsOptional()
  @IsEnum(['1d', '3d', '7d', '30d'])
  posted_within?: string;

  @IsOptional()
  @IsEnum(['newest', 'budget_high', 'budget_low', 'relevance'])
  @Transform(({ value }) => value || 'relevance')
  sort?: string;

  @IsOptional()
  @IsNumber()
  @Min(1)
  @Max(100)
  @Transform(({ value }) => parseInt(value) || 20)
  limit?: number;

  @IsOptional()
  @IsNumber()
  @Min(1)
  @Transform(({ value }) => parseInt(value) || 1)
  page?: number;
}
```

### Stripe Payment Integration with Webhook Handling
```typescript
@Controller('payments')
@UseGuards(JwtAuthGuard)
export class PaymentController {
  
  @Post('create-payment-intent')
  @UseGuards(RoleGuard('client'))
  async createPaymentIntent(@Body() paymentDto: CreatePaymentIntentDto): Promise<{ clientSecret: string, intentId: string }> {
    // 1. Validate contract and milestone
    // 2. Calculate total amount (milestone + platform fee + stripe fee)
    // 3. Create Stripe payment intent with metadata
    // 4. Store payment record
    // 5. Return client secret for frontend
  }

  @Post('fund-escrow')
  @UseGuards(RoleGuard('client'))
  async fundEscrow(@Body() fundDto: FundEscrowDto): Promise<{ success: boolean }> {
    // 1. Validate payment intent confirmation
    // 2. Update contract escrow balance
    // 3. Notify freelancer of funding
    // 4. Update milestone status to 'in_progress'
    // 5. Log transaction
  }

  @Post('release-milestone')
  @UseGuards(RoleGuard('client'))
  async releaseMilestone(@Body() releaseDto: ReleaseMilestoneDto): Promise<{ success: boolean }> {
    // 1. Validate milestone completion
    // 2. Calculate freelancer payout (amount - platform fee)
    // 3. Create Stripe transfer to freelancer's connected account
    // 4. Update payment and milestone status
    // 5. Send notifications
    // 6. Update freelancer earnings statistics
  }

  @Post('webhooks/stripe')
  @UseGuards(StripeWebhookGuard) // Validates Stripe signature
  async handleStripeWebhook(@Request() req): Promise<{ received: boolean }> {
    // 1. Verify webhook signature
    // 2. Parse event data
    // 3. Handle different event types:
    //    - payment_intent.succeeded
    //    - payment_intent.payment_failed
    //    - transfer.created
    //    - account.updated
    // 4. Update database records
    // 5. Send notifications
    // 6. Handle idempotency
  }

  @Get('balance')
  @UseGuards(RoleGuard('freelancer'))
  async getBalance(@Request() req): Promise<FreelancerBalance> {
    // 1. Get all completed milestones
    // 2. Calculate total earnings
    // 3. Calculate pending earnings (in escrow)
    // 4. Calculate available for withdrawal
    // 5. Get transaction history
  }

  @Post('withdraw')
  @UseGuards(RoleGuard('freelancer'))
  async createWithdrawal(@Body() withdrawDto: WithdrawDto): Promise<{ success: boolean }> {
    // 1. Validate withdrawal amount
    // 2. Check Stripe connected account status
    // 3. Create Stripe payout
    // 4. Update balance records
    // 5. Send confirmation
  }
}

// Stripe service with error handling
@Injectable()
export class StripeService {
  private stripe: Stripe;
  
  constructor(private configService: ConfigService) {
    this.stripe = new Stripe(configService.get('STRIPE_SECRET_KEY'), {
      apiVersion: '2023-10-16'
    });
  }

  async createPaymentIntent(params: CreatePaymentIntentParams): Promise<Stripe.PaymentIntent> {
    try {
      return await this.stripe.paymentIntents.create({
        amount: Math.round(params.amount * 100), // Convert to cents
        currency: params.currency,
        metadata: {
          contractId: params.contractId,
          milestoneIndex: params.milestoneIndex?.toString(),
          type: params.type
        },
        application_fee_amount: Math.round(params.platformFee * 100)
      });
    } catch (error) {
      this.logger.error('Failed to create payment intent', error);
      throw new BadRequestException('Payment processing failed');
    }
  }

  async createTransfer(params: CreateTransferParams): Promise<Stripe.Transfer> {
    try {
      return await this.stripe.transfers.create({
        amount: Math.round(params.amount * 100),
        currency: params.currency,
        destination: params.connectedAccountId,
        metadata: {
          contractId: params.contractId,
          milestoneIndex: params.milestoneIndex?.toString()
        }
      });
    } catch (error) {
      this.logger.error('Failed to create transfer', error);
      throw new BadRequestException('Transfer failed');
    }
  }

  async constructWebhookEvent(body: string, signature: string): Promise<Stripe.Event> {
    try {
      return this.stripe.webhooks.constructEvent(
        body, 
        signature, 
        this.configService.get('STRIPE_WEBHOOK_SECRET')
      );
    } catch (error) {
      this.logger.error('Webhook signature verification failed', error);
      throw new BadRequestException('Invalid webhook signature');
    }
  }
}
```

### Real-time Messaging with WebSockets
```typescript
@WebSocketGateway({
  cors: {
    origin: process.env.FRONTEND_URL,
    credentials: true
  },
  transports: ['websocket']
})
export class MessagingGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private connectedUsers = new Map<string, string>(); // userId -> socketId

  constructor(
    private messageService: MessageService,
    private jwtService: JwtService
  ) {}

  async handleConnection(client: Socket) {
    try {
      const token = client.handshake.auth.token;
      const payload = this.jwtService.verify(token);
      
      client.data.userId = payload.sub;
      this.connectedUsers.set(payload.sub, client.id);
      
      // Join user to their personal room
      client.join(`user_${payload.sub}`);
      
      // Update user online status
      await this.userService.updateOnlineStatus(payload.sub, true);
      
      this.logger.log(`User ${payload.sub} connected`);
    } catch (error) {
      client.disconnect();
    }
  }

  async handleDisconnect(client: Socket) {
    if (client.data.userId) {
      this.connectedUsers.delete(client.data.userId);
      await this.userService.updateOnlineStatus(client.data.userId, false);
      this.logger.log(`User ${client.data.userId} disconnected`);
    }
  }

  @SubscribeMessage('send_message')
  async handleMessage(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: SendMessageDto
  ) {
    // 1. Validate user permissions
    // 2. Save message to database
    // 3. Send to recipient if online
    // 4. Send push notification if offline
    // 5. Update conversation metadata
    
    const message = await this.messageService.createMessage({
      senderId: client.data.userId,
      receiverId: data.receiverId,
      content: data.content,
      attachments: data.attachments
    });

    // Emit to recipient
    this.server.to(`user_${data.receiverId}`).emit('new_message', message);
    
    // Emit back to sender for confirmation
    client.emit('message_sent', { messageId: message._id, status: 'delivered' });
  }

  @SubscribeMessage('mark_read')
  async handleMarkRead(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { conversationId: string }
  ) {
    await this.messageService.markConversationAsRead(
      data.conversationId,
      client.data.userId
    );
    
    // Notify other party that messages were read
    const conversation = await this.messageService.getConversation(data.conversationId);
    const otherUserId = conversation.participants.find(id => id !== client.data.userId);
    
    this.server.to(`user_${otherUserId}`).emit('messages_read', {
      conversationId: data.conversationId,
      readBy: client.data.userId
    });
  }

  @SubscribeMessage('typing_stop')
  async handleTypingStop(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { conversationId: string, receiverId: string }
  ) {
    this.server.to(`user_${data.receiverId}`).emit('user_typing', {
      conversationId: data.conversationId,
      userId: client.data.userId,
      isTyping: false
    });
  }

  // Send real-time notifications
  async sendNotification(userId: string, notification: any) {
    this.server.to(`user_${userId}`).emit('notification', notification);
  }
}
```

## Advanced Business Logic Implementation

### Escrow Management Service
```typescript
@Injectable()
export class EscrowService {
  constructor(
    private stripeService: StripeService,
    private contractService: ContractService,
    private notificationService: NotificationService
  ) {}

  async fundEscrow(contractId: string, paymentIntentId: string): Promise<void> {
    const contract = await this.contractService.findById(contractId);
    const paymentIntent = await this.stripeService.retrievePaymentIntent(paymentIntentId);
    
    if (paymentIntent.status !== 'succeeded') {
      throw new BadRequestException('Payment not confirmed');
    }

    // Calculate amounts
    const totalAmount = paymentIntent.amount / 100; // Convert from cents
    const platformFee = totalAmount * contract.escrow.platformFeeRate;
    const stripeFee = totalAmount * contract.escrow.stripeFeeRate + 0.30;
    const escrowAmount = totalAmount - platformFee - stripeFee;

    // Update contract escrow
    await this.contractService.updateEscrow(contractId, {
      totalEscrowed: contract.escrow.totalEscrowed + escrowAmount,
      availableForRelease: contract.escrow.availableForRelease + escrowAmount
    });

    // Create payment record
    await this.paymentService.create({
      contractId,
      stripePaymentIntentId: paymentIntentId,
      amount: totalAmount,
      type: 'escrow_funding',
      status: 'succeeded',
      platformFee,
      stripeFee,
      freelancerAmount: escrowAmount
    });

    // Notify freelancer
    await this.notificationService.send({
      userId: contract.freelancerId,
      type: 'payment',
      title: 'Project Funded',
      message: `${escrowAmount.toFixed(2)} USD has been escrowed for your project`,
      priority: 'medium'
    });

    // Update milestone status
    if (contract.milestones[contract.currentMilestone]?.status === 'pending') {
      await this.contractService.updateMilestoneStatus(
        contractId, 
        contract.currentMilestone, 
        'in_progress'
      );
    }
  }

  async releaseMilestone(contractId: string, milestoneIndex: number, clientId: string): Promise<void> {
    const contract = await this.contractService.findById(contractId);
    
    // Validate client ownership
    if (contract.clientId.toString() !== clientId) {
      throw new ForbiddenException('Not authorized to release funds');
    }

    const milestone = contract.milestones[milestoneIndex];
    if (milestone.status !== 'submitted') {
      throw new BadRequestException('Milestone not ready for approval');
    }

    // Calculate release amount
    const releaseAmount = milestone.amount;
    if (contract.escrow.availableForRelease < releaseAmount) {
      throw new BadRequestException('Insufficient escrow funds');
    }

    try {
      // Get freelancer's Stripe connected account
      const freelancer = await this.userService.findById(contract.freelancerId);
      if (!freelancer.stripeConnectedAccountId) {
        throw new BadRequestException('Freelancer payment account not set up');
      }

      // Create Stripe transfer
      const transfer = await this.stripeService.createTransfer({
        amount: releaseAmount,
        currency: 'USD',
        connectedAccountId: freelancer.stripeConnectedAccountId,
        contractId,
        milestoneIndex
      });

      // Update contract escrow
      await this.contractService.updateEscrow(contractId, {
        availableForRelease: contract.escrow.availableForRelease - releaseAmount,
        released: contract.escrow.released + releaseAmount
      });

      // Update milestone status
      await this.contractService.updateMilestoneStatus(contractId, milestoneIndex, 'approved');

      // Create payment record
      await this.paymentService.create({
        contractId,
        milestoneIndex,
        stripePaymentIntentId: transfer.id,
        amount: releaseAmount,
        type: 'milestone_release',
        status: 'succeeded',
        platformFee: 0,
        stripeFee: 0,
        freelancerAmount: releaseAmount
      });

      // Update freelancer stats
      await this.freelancerService.updateEarnings(contract.freelancerId, releaseAmount);

      // Send notifications
      await this.notificationService.send({
        userId: contract.freelancerId,
        type: 'payment',
        title: 'Payment Released',
        message: `${releaseAmount.toFixed(2)} USD has been released to your account`,
        priority: 'high'
      });

      // Check if contract is complete
      const allMilestonesCompleted = contract.milestones.every(m => m.status === 'approved');
      if (allMilestonesCompleted) {
        await this.completeContract(contractId);
      }

    } catch (error) {
      this.logger.error('Failed to release milestone payment', error);
      throw new InternalServerErrorException('Payment release failed');
    }
  }

  private async completeContract(contractId: string): Promise<void> {
    await this.contractService.updateStatus(contractId, 'completed');
    
    const contract = await this.contractService.findById(contractId);
    
    // Update project status
    await this.projectService.updateStatus(contract.projectId, 'completed');
    
    // Prompt for reviews
    await this.notificationService.send({
      userId: contract.clientId,
      type: 'review',
      title: 'Project Completed - Leave Review',
      message: 'Your project has been completed. Please leave a review for your freelancer.',
      priority: 'medium'
    });

    await this.notificationService.send({
      userId: contract.freelancerId,
      type: 'review',
      title: 'Project Completed - Leave Review',
      message: 'Your project has been completed. Please leave a review for your client.',
      priority: 'medium'
    });
  }
}
```

### Sophisticated Search and Recommendation Engine
```typescript
@Injectable()
export class SearchService {
  constructor(
    private readonly projectModel: Model<Project>,
    private readonly freelancerModel: Model<FreelancerProfile>,
    private readonly userActivityService: UserActivityService,
    private readonly cacheService: CacheService
  ) {}

  async searchProjects(params: SearchProjectsDto, userId?: string): Promise<PaginatedResponse<Project>> {
    const cacheKey = `search:projects:${JSON.stringify(params)}`;
    const cached = await this.cacheService.get(cacheKey);
    if (cached) return cached;

    // Build aggregation pipeline
    const pipeline: PipelineStage[] = [
      // Match basic filters
      {
        $match: {
          status: 'open',
          visibility: 'public'
        }
      }
    ];

    // Text search
    if (params.query) {
      pipeline.push({
        $match: {
          $text: { $search: params.query }
        }
      });
      pipeline.push({
        $addFields: {
          searchScore: { $meta: 'textScore' }
        }
      });
    }

    // Category filter
    if (params.category) {
      pipeline.push({
        $match: { category: params.category }
      });
    }

    // Skills filter
    if (params.skills?.length > 0) {
      pipeline.push({
        $match: {
          requiredSkills: { $in: params.skills }
        }
      });
    }

    // Budget range filter
    if (params.budget_min || params.budget_max) {
      const budgetMatch: any = {};
      if (params.budget_min) {
        budgetMatch['budget.amount'] = { $gte: params.budget_min };
      }
      if (params.budget_max) {
        if (budgetMatch['budget.amount']) {
          budgetMatch['budget.amount'].$lte = params.budget_max;
        } else {
          budgetMatch['budget.amount'] = { $lte: params.budget_max };
        }
      }
      pipeline.push({ $match: budgetMatch });
    }

    // Time filter
    if (params.posted_within) {
      const timeMap = {
        '1d': 1,
        '3d': 3,
        '7d': 7,
        '30d': 30
      };
      const days = timeMap[params.posted_within];
      const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      pipeline.push({
        $match: {
          createdAt: { $gte: cutoffDate }
        }
      });
    }

    // Lookup client information
    pipeline.push({
      $lookup: {
        from: 'users',
        localField: 'clientId',
        foreignField: '_id',
        as: 'client'
      }
    });

    pipeline.push({
      $lookup: {
        from: 'clientprofiles',
        localField: 'clientId',
        foreignField: 'userId',
        as: 'clientProfile'
      }
    });

    // Add computed fields
    pipeline.push({
      $addFields: {
        client: { $arrayElemAt: ['$client', 0] },
        clientProfile: { $arrayElemAt: ['$clientProfile', 0] },
        proposalCount: { $size: '$proposals.received' },
        relevanceScore: {
          $cond: {
            if: { $exists: '$searchScore' },
            then: '$searchScore',
            else: 1
          }
        }
      }
    });

    // Sorting
    const sortStage: any = {};
    switch (params.sort) {
      case 'newest':
        sortStage.createdAt = -1;
        break;
      case 'budget_high':
        sortStage['budget.amount'] = -1;
        break;
      case 'budget_low':
        sortStage['budget.amount'] = 1;
        break;
      case 'relevance':
      default:
        if (params.query) {
          sortStage.searchScore = { $meta: 'textScore' };
        } else {
          sortStage.createdAt = -1;
        }
        break;
    }
    pipeline.push({ $sort: sortStage });

    // Pagination
    const skip = (params.page - 1) * params.limit;
    pipeline.push({ $skip: skip });
    pipeline.push({ $limit: params.limit });

    // Execute search
    const [results, totalCount] = await Promise.all([
      this.projectModel.aggregate(pipeline).exec(),
      this.getSearchCount(pipeline.slice(0, -2)) // Remove skip and limit for count
    ]);

    const response = {
      data: results,
      pagination: {
        page: params.page,
        limit: params.limit,
        total: totalCount,
        pages: Math.ceil(totalCount / params.limit)
      }
    };

    // Cache results for 5 minutes
    await this.cacheService.set(cacheKey, response, 300);

    // Track search activity
    if (userId) {
      await this.userActivityService.trackSearch(userId, params, results.length);
    }

    return response;
  }

  async getRecommendations(freelancerId: string): Promise<Project[]> {
    const cacheKey = `recommendations:${freelancerId}`;
    const cached = await this.cacheService.get(cacheKey);
    if (cached) return cached;

    const freelancer = await this.freelancerModel.findOne({ userId: freelancerId }).populate('userId');
    if (!freelancer) return [];

    // Get freelancer's primary skills and categories
    const userSkills = freelancer.skills.primary.concat(freelancer.skills.secondary || []);
    const userCategories = freelancer.skills.categories;

    // Get freelancer's project history for behavior analysis
    const completedProjects = await this.contractService.getFreelancerCompletedProjects(freelancerId);
    const avgProjectValue = this.calculateAverageProjectValue(completedProjects);
    const successCategories = this.getSuccessfulCategories(completedProjects);

    // Build recommendation pipeline
    const pipeline: PipelineStage[] = [
      {
        $match: {
          status: 'open',
          visibility: 'public',
          clientId: { $ne: new Types.ObjectId(freelancerId) } // Don't recommend own projects
        }
      },
      {
        $addFields: {
          skillMatchScore: {
            $size: {
              $setIntersection: ['$requiredSkills', userSkills]
            }
          },
          categoryMatch: {
            $cond: {
              if: { $in: ['$category', userCategories] },
              then: 1,
              else: 0
            }
          },
          budgetFitScore: this.getBudgetFitScore(avgProjectValue),
          successCategoryBonus: {
            $cond: {
              if: { $in: ['$category', successCategories] },
              then: 0.5,
              else: 0
            }
          }
        }
      },
      {
        $addFields: {
          recommendationScore: {
            $add: [
              { $multiply: ['$skillMatchScore', 2] }, // Skills are most important
              '$categoryMatch',
              '$budgetFitScore',
              '$successCategoryBonus',
              { $divide: [{ $subtract: [10, '$proposals.count'] }, 10] } // Prefer less competitive
            ]
          }
        }
      },
      {
        $match: {
          $or: [
            { skillMatchScore: { $gte: 1 } }, // At least one skill match
            { categoryMatch: 1 } // Or category match
          ]
        }
      },
      {
        $sort: { recommendationScore: -1, createdAt: -1 }
      },
      { $limit: 20 },
      {
        $lookup: {
          from: 'users',
          localField: 'clientId',
          foreignField: '_id',
          as: 'client'
        }
      }
    ];

    const recommendations = await this.projectModel.aggregate(pipeline).exec();

    // Cache recommendations for 1 hour
    await this.cacheService.set(cacheKey, recommendations, 3600);

    return recommendations;
  }

  private getBudgetFitScore(avgProjectValue: number): any {
    return {
      $cond: {
        if: { $and: [
          { $gte: ['$budget.amount', avgProjectValue * 0.5] },
          { $lte: ['$budget.amount', avgProjectValue * 2] }
        ]},
        then: 1,
        else: 0.5
      }
    };
  }

  private calculateAverageProjectValue(projects: any[]): number {
    if (projects.length === 0) return 1000; // Default value
    const total = projects.reduce((sum, project) => sum + project.terms.totalAmount, 0);
    return total / projects.length;
  }

  private getSuccessfulCategories(projects: any[]): string[] {
    const categorySuccess = projects
      .filter(p => p.status === 'completed' && p.clientRating >= 4.0)
      .reduce((acc, project) => {
        const category = project.category;
        acc[category] = (acc[category] || 0) + 1;
        return acc;
      }, {});

    return Object.entries(categorySuccess)
      .filter(([_, count]) => count >= 2) // At least 2 successful projects
      .map(([category]) => category);
  }
}
```

## Comprehensive Error Handling and Logging

### Global Exception Filter
```typescript
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(GlobalExceptionFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status: number;
    let message: string;
    let code: string;
    let details: any = null;

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      const responseBody = exception.getResponse();
      
      if (typeof responseBody === 'object' && responseBody !== null) {
        message = (responseBody as any).message || exception.message;
        code = (responseBody as any).code || exception.constructor.name;
        details = (responseBody as any).details;
      } else {
        message = responseBody as string;
        code = exception.constructor.name;
      }
    } else if (exception instanceof MongoError) {
      status = 400;
      code = 'DATABASE_ERROR';
      
      if (exception.code === 11000) {
        message = 'Duplicate entry detected';
        details = this.parseDuplicateKeyError(exception);
      } else {
        message = 'Database operation failed';
      }
    } else if (exception instanceof Stripe.errors.StripeError) {
      status = 402; // Payment Required
      code = 'PAYMENT_ERROR';
      message = exception.message;
      details = {
        type: exception.type,
        code: exception.code,
        decline_code: (exception as any).decline_code
      };
    } else {
      status = 500;
      message = 'Internal server error';
      code = 'INTERNAL_ERROR';
    }

    // Log error details
    this.logger.error(
      `${request.method} ${request.url}`,
      {
        statusCode: status,
        message,
        code,
        details,
        stack: exception instanceof Error ? exception.stack : undefined,
        userId: request.user?.sub,
        timestamp: new Date().toISOString(),
        userAgent: request.get('User-Agent'),
        ip: request.ip
      }
    );

    // Don't expose sensitive information in production
    const isProduction = process.env.NODE_ENV === 'production';
    const errorResponse = {
      success: false,
      error: {
        code,
        message,
        ...(details && !isProduction && { details }),
        timestamp: new Date().toISOString(),
        path: request.url
      }
    };

    response.status(status).json(errorResponse);
  }

  private parseDuplicateKeyError(error: MongoError): any {
    const field = Object.keys((error as any).keyPattern)[0];
    return {
      field,
      message: `${field} already exists`
    };
  }
}
```

### Comprehensive Validation System
```typescript
// Custom validators for business logic
export function IsValidProjectBudget(validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isValidProjectBudget',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any) {
          if (!value || typeof value !== 'object') return false;
          
          if (value.type === 'fixed') {
            return value.amount && value.amount >= 5 && value.amount <= 100000;
          } else if (value.type === 'hourly') {
            return value.hourlyRate && 
                   value.hourlyRate.min >= 1 && 
                   value.hourlyRate.max <= 500 &&
                   value.hourlyRate.min <= value.hourlyRate.max;
          }
          return false;
        },
        defaultMessage: () => 'Invalid budget configuration'
      }
    });
  };
}

export function IsValidSkillArray(validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isValidSkillArray',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any) {
          if (!Array.isArray(value)) return false;
          if (value.length === 0 || value.length > 20) return false;
          
          // Check for duplicates
          const uniqueSkills = new Set(value);
          if (uniqueSkills.size !== value.length) return false;
          
          // Validate each skill format
          return value.every(skill => 
            typeof skill === 'string' && 
            skill.length >= 2 && 
            skill.length <= 50 &&
            /^[a-zA-Z0-9\s\-+#.]+$/.test(skill)
          );
        },
        defaultMessage: () => 'Skills must be unique, valid format, and between 1-20 items'
      }
    });
  };
}

// DTO with comprehensive validation
export class CreateProjectDto {
  @IsString()
  @Length(10, 150)
  @Transform(({ value }) => value.trim())
  title: string;

  @IsString()
  @Length(100, 5000)
  @Transform(({ value }) => value.trim())
  description: string;

  @IsString()
  @IsIn(['technology', 'design', 'writing', 'marketing', 'business', 'education', 'translation'])
  category: string;

  @IsOptional()
  @IsString()
  @Length(2, 50)
  subcategory?: string;

  @IsValidSkillArray()
  requiredSkills: string[];

  @IsEnum(['fixed', 'hourly'])
  type: ProjectType;

  @IsValidProjectBudget()
  budget: ProjectBudget;

  @IsOptional()
  @ValidateNested()
  @Type(() => ProjectTimelineDto)
  timeline?: ProjectTimelineDto;

  @IsOptional()
  @IsArray()
  @ArrayMaxSize(10)
  @IsUrl({}, { each: true })
  attachments?: string[];

  @IsOptional()
  @IsEnum(['public', 'private'])
  @Transform(({ value }) => value || 'public')
  visibility?: ProjectVisibility;

  @IsOptional()
  @IsArray()
  @ArrayMaxSize(50)
  @IsMongoId({ each: true })
  invitedFreelancers?: string[];
}

export class ProjectTimelineDto {
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(365)
  duration?: number;

  @IsOptional()
  @IsDateString()
  @Transform(({ value }) => {
    const date = new Date(value);
    const minDate = new Date(Date.now() + 24 * 60 * 60 * 1000); // Tomorrow
    return date > minDate ? value : undefined;
  })
  deadline?: string;

  @IsOptional()
  @IsBoolean()
  isUrgent?: boolean;
}
```

## Security Implementation

### Advanced Rate Limiting
```typescript
@Injectable()
export class CustomRateLimitGuard implements CanActivate {
  constructor(
    private readonly cacheService: CacheService,
    private readonly configService: ConfigService
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const key = this.generateKey(request);
    const limit = this.getLimit(request);
    const windowSize = this.getWindowSize(request);

    const current = await this.cacheService.get(key) || 0;
    
    if (current >= limit) {
      throw new ThrottlerException();
    }

    await this.cacheService.increment(key, windowSize);
    
    // Add rate limit headers
    const response = context.switchToHttp().getResponse();
    response.setHeader('X-RateLimit-Limit', limit);
    response.setHeader('X-RateLimit-Remaining', Math.max(0, limit - current - 1));
    response.setHeader('X-RateLimit-Reset', new Date(Date.now() + windowSize * 1000));

    return true;
  }

  private generateKey(request: any): string {
    const ip = request.ip;
    const userId = request.user?.sub;
    const endpoint = `${request.method}:${request.route?.path}`;
    
    // Use userId if authenticated, otherwise IP
    const identifier = userId || ip;
    return `rate_limit:${identifier}:${endpoint}`;
  }

  private getLimit(request: any): number {
    const endpoint = `${request.method}:${request.route?.path}`;
    
    // Different limits for different endpoints
    const limits = {
      'POST:/auth/login': 5, // Login attempts
      'POST:/auth/register': 3, // Registration attempts
      'POST:/projects': 10, // Project creation
      'POST:/proposals': 20, // Proposal submission
      'POST:/messages': 100, // Messaging
      'default': 60
    };

    return limits[endpoint] || limits.default;
  }

  private getWindowSize(request: any): number {
    const endpoint = `${request.method}:${request.route?.path}`;
    
    // Different time windows (in seconds)
    const windows = {
      'POST:/auth/login': 900, // 15 minutes for login
      'POST:/auth/register': 3600, // 1 hour for registration
      'POST:/projects': 3600, // 1 hour for projects
      'default': 60 // 1 minute default
    };

    return windows[endpoint] || windows.default;
  }
}

// Input sanitization middleware
@Injectable()
export class SanitizationMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // Recursively sanitize all string inputs
    this.sanitizeObject(req.body);
    this.sanitizeObject(req.query);
    this.sanitizeObject(req.params);
    
    next();
  }

  private sanitizeObject(obj: any): void {
    if (!obj || typeof obj !== 'object') return;

    for (const key in obj) {
      if (typeof obj[key] === 'string') {
        // Remove potentially dangerous HTML/JS
        obj[key] = this.sanitizeString(obj[key]);
      } else if (typeof obj[key] === 'object') {
        this.sanitizeObject(obj[key]);
      }
    }
  }

  private sanitizeString(str: string): string {
    // Remove script tags, on* attributes, javascript: links
    return str
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/on\w+\s*=\s*["'][^"']*["']/gi, '')
      .replace(/javascript:/gi, '')
      .trim();
  }
}
```

## Production Deployment Configuration

### Docker Configuration
```dockerfile
# Multi-stage build for production
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY tsconfig*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY src/ src/

# Build application
RUN npm run build

# Production image
FROM node:18-alpine AS production

WORKDIR /app

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nestjs -u 1001

# Copy built application
COPY --from=builder /app/dist dist/
COPY --from=builder /app/node_modules node_modules/
COPY package*.json ./

# Change ownership to non-root user
RUN chown -R nestjs:nodejs /app
USER nestjs

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

EXPOSE 3000

CMD ["node", "dist/main.js"]
```

### Environment Configuration
```typescript
// config/configuration.ts
export default () => ({
  port: parseInt(process.env.PORT, 10) || 3000,
  database: {
    uri: process.env.MONGODB_URI || 'mongodb://localhost:27017/freelancehub',
    options: {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      maxPoolSize: parseInt(process.env.DB_POOL_SIZE, 10) || 10,
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000,
    }
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT, 10) || 6379,
    password: process.env.REDIS_PASSWORD,
    db: parseInt(process.env.REDIS_DB, 10) || 0,
    retryDelayOnFailover: 100,
    enableReadyCheck: false,
    maxRetriesPerRequest: 3,
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '15m',
    refreshSecret: process.env.JWT_REFRESH_SECRET,
    refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d',
  },
  stripe: {
    secretKey: process.env.STRIPE_SECRET_KEY,
    publishableKey: process.env.STRIPE_PUBLISHABLE_KEY,
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET,
  },
  aws: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    region: process.env.AWS_REGION || 'us-east-1',
    s3Bucket: process.env.AWS_S3_BUCKET,
  },
  email: {
    from: process.env.EMAIL_FROM || 'noreply@freelancehub.lk',
    service: process.env.EMAIL_SERVICE || 'sendgrid',
    apiKey: process.env.EMAIL_API_KEY,
  },
  frontend: {
    url: process.env.FRONTEND_URL || 'http://localhost:3001',
    cors: {
      origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3001'],
      credentials: true,
    }
  },
  monitoring: {
    sentryDsn: process.env.SENTRY_DSN,
    logLevel: process.env.LOG_LEVEL || 'info',
  }
});
```

business logic, and deployment configurations needed for FreelanceHub.

## Testing Strategy

### Unit Testing Setup
```typescript
// test/setup.ts
import { MongoMemoryServer } from 'mongodb-memory-server';
import { Test } from '@nestjs/testing';
import { getModelToken } from '@nestjs/mongoose';
import { Model } from 'mongoose';

export class TestDatabase {
  private mongod: MongoMemoryServer;

  async start(): Promise<string> {
    this.mongod = await MongoMemoryServer.create();
    return this.mongod.getUri();
  }

  async stop(): Promise<void> {
    if (this.mongod) {
      await this.mongod.stop();
    }
  }

  async cleanup(): Promise<void> {
    // Clean collections between tests
  }
}

// Example service test
describe('ProjectService', () => {
  let service: ProjectService;
  let projectModel: Model<Project>;
  let testDb: TestDatabase;

  beforeAll(async () => {
    testDb = new TestDatabase();
    const uri = await testDb.start();

    const module = await Test.createTestingModule({
      imports: [
        MongooseModule.forRoot(uri),
        MongooseModule.forFeature([
          { name: 'Project', schema: ProjectSchema },
          { name: 'User', schema: UserSchema }
        ])
      ],
      providers: [ProjectService]
    }).compile();

    service = module.get<ProjectService>(ProjectService);
    projectModel = module.get<Model<Project>>(getModelToken('Project'));
  });

  afterAll(async () => {
    await testDb.stop();
  });

  afterEach(async () => {
    await testDb.cleanup();
  });

  describe('createProject', () => {
    it('should create project with valid data', async () => {
      const createDto: CreateProjectDto = {
        title: 'Test Project',
        description: 'This is a test project description that is long enough to meet requirements.',
        category: 'technology',
        requiredSkills: ['JavaScript', 'Node.js'],
        type: 'fixed',
        budget: {
          type: 'fixed',
          amount: 1000,
          currency: 'USD'
        }
      };

      const result = await service.create(createDto, 'user123');

      expect(result).toBeDefined();
      expect(result.title).toBe(createDto.title);
      expect(result.status).toBe('draft');
      expect(result.clientId).toBe('user123');
    });

    it('should throw error for invalid budget', async () => {
      const createDto: CreateProjectDto = {
        title: 'Test Project',
        description: 'This is a test project description.',
        category: 'technology',
        requiredSkills: ['JavaScript'],
        type: 'fixed',
        budget: {
          type: 'fixed',
          amount: 1, // Below minimum
          currency: 'USD'
        }
      };

      await expect(service.create(createDto, 'user123'))
        .rejects
        .toThrow('Budget must be at least $5');
    });
  });
});
```

### Integration Testing
```typescript
// test/auth.e2e-spec.ts
import { Test } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Authentication (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('/auth/register (POST)', () => {
    it('should register new user', () => {
      return request(app.getHttpServer())
        .post('/auth/register')
        .send({
          email: 'test@example.com',
          username: 'testuser',
          firstName: 'Test',
          lastName: 'User',
          primaryRole: 'freelancer',
          country: 'Sri Lanka',
          city: 'Colombo'
        })
        .expect(201)
        .expect((res) => {
          expect(res.body.message).toContain('Registration successful');
          expect(res.body.verificationRequired).toBe(true);
        });
    });

    it('should reject duplicate email', () => {
      // First registration
      return request(app.getHttpServer())
        .post('/auth/register')
        .send({
          email: 'duplicate@example.com',
          username: 'user1',
          firstName: 'Test',
          lastName: 'User',
          primaryRole: 'freelancer',
          country: 'Sri Lanka',
          city: 'Colombo'
        })
        .expect(201)
        .then(() => {
          // Second registration with same email
          return request(app.getHttpServer())
            .post('/auth/register')
            .send({
              email: 'duplicate@example.com',
              username: 'user2',
              firstName: 'Test',
              lastName: 'User',
              primaryRole: 'client',
              country: 'Sri Lanka',
              city: 'Kandy'
            })
            .expect(400);
        });
    });
  });
});
```

## Monitoring and Observability

### Application Metrics
```typescript
// monitoring/metrics.service.ts
import { Injectable } from '@nestjs/common';
import { Counter, Histogram, Gauge, register } from 'prom-client';

@Injectable()
export class MetricsService {
  private readonly httpRequestsTotal: Counter<string>;
  private readonly httpRequestDuration: Histogram<string>;
  private readonly activeUsers: Gauge<string>;
  private readonly projectsCreated: Counter<string>;
  private readonly paymentsProcessed: Counter<string>;
  private readonly errorRate: Counter<string>;

  constructor() {
    this.httpRequestsTotal = new Counter({
      name: 'http_requests_total',
      help: 'Total number of HTTP requests',
      labelNames: ['method', 'route', 'status_code'],
    });

    this.httpRequestDuration = new Histogram({
      name: 'http_request_duration_seconds',
      help: 'Duration of HTTP requests in seconds',
      labelNames: ['method', 'route'],
      buckets: [0.1, 0.5, 1, 2, 5],
    });

    this.activeUsers = new Gauge({
      name: 'active_users_total',
      help: 'Number of currently active users',
    });

    this.projectsCreated = new Counter({
      name: 'projects_created_total',
      help: 'Total number of projects created',
      labelNames: ['category', 'type'],
    });

    this.paymentsProcessed = new Counter({
      name: 'payments_processed_total',
      help: 'Total number of payments processed',
      labelNames: ['type', 'status', 'currency'],
    });

    this.errorRate = new Counter({
      name: 'application_errors_total',
      help: 'Total number of application errors',
      labelNames: ['type', 'severity'],
    });
  }

  recordHttpRequest(method: string, route: string, statusCode: number, duration: number) {
    this.httpRequestsTotal.labels(method, route, statusCode.toString()).inc();
    this.httpRequestDuration.labels(method, route).observe(duration);
  }

  setActiveUsers(count: number) {
    this.activeUsers.set(count);
  }

  recordProjectCreation(category: string, type: string) {
    this.projectsCreated.labels(category, type).inc();
  }

  recordPayment(type: string, status: string, currency: string) {
    this.paymentsProcessed.labels(type, status, currency).inc();
  }

  recordError(type: string, severity: 'low' | 'medium' | 'high' | 'critical') {
    this.errorRate.labels(type, severity).inc();
  }

  getMetrics(): Promise<string> {
    return register.metrics();
  }
}

// Health check controller
@Controller('health')
export class HealthController {
  constructor(
    private readonly mongoHealthIndicator: MongooseHealthIndicator,
    private readonly redisHealthIndicator: RedisHealthIndicator,
    private readonly stripeHealthIndicator: StripeHealthIndicator,
    private readonly metricsService: MetricsService
  ) {}

  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      () => this.mongoHealthIndicator.pingCheck('mongodb'),
      () => this.redisHealthIndicator.pingCheck('redis'),
      () => this.stripeHealthIndicator.pingCheck('stripe'),
    ]);
  }

  @Get('metrics')
  async getMetrics(): Promise<string> {
    return this.metricsService.getMetrics();
  }

  @Get('ready')
  readiness() {
    // Check if application is ready to serve traffic
    return { status: 'ok', timestamp: new Date().toISOString() };
  }

  @Get('live')
  liveness() {
    // Check if application is alive
    return { status: 'ok', timestamp: new Date().toISOString() };
  }
}
```

### Structured Logging
```typescript
// logging/logger.service.ts
import { Injectable, LoggerService } from '@nestjs/common';
import * as winston from 'winston';

@Injectable()
export class CustomLogger implements LoggerService {
  private logger: winston.Logger;

  constructor() {
    this.logger = winston.createLogger({
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      transports: [
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        }),
        new winston.transports.File({
          filename: 'logs/error.log',
          level: 'error'
        }),
        new winston.transports.File({
          filename: 'logs/combined.log'
        })
      ]
    });
  }

  log(message: string, context?: string) {
    this.logger.info(message, { context });
  }

  error(message: string, trace?: string, context?: string) {
    this.logger.error(message, { trace, context });
  }

  warn(message: string, context?: string) {
    this.logger.warn(message, { context });
  }

  debug(message: string, context?: string) {
    this.logger.debug(message, { context });
  }

  verbose(message: string, context?: string) {
    this.logger.verbose(message, { context });
  }

  // Business event logging
  logBusinessEvent(event: string, data: any, userId?: string) {
    this.logger.info('Business Event', {
      event,
      data,
      userId,
      timestamp: new Date().toISOString(),
      type: 'business_event'
    });
  }

  // Security event logging
  logSecurityEvent(event: string, data: any, userId?: string, ip?: string) {
    this.logger.warn('Security Event', {
      event,
      data,
      userId,
      ip,
      timestamp: new Date().toISOString(),
      type: 'security_event'
    });
  }

  // Performance logging
  logPerformance(operation: string, duration: number, metadata?: any) {
    this.logger.info('Performance Log', {
      operation,
      duration,
      metadata,
      timestamp: new Date().toISOString(),
      type: 'performance'
    });
  }
}
```

## Performance Optimization

### Caching Strategy
```typescript
// caching/cache.service.ts
@Injectable()
export class CacheService {
  constructor(@InjectRedis() private readonly redis: Redis) {}

  // Basic cache operations
  async get<T>(key: string): Promise<T | null> {
    const value = await this.redis.get(key);
    return value ? JSON.parse(value) : null;
  }

  async set(key: string, value: any, ttl?: number): Promise<void> {
    const serialized = JSON.stringify(value);
    if (ttl) {
      await this.redis.setex(key, ttl, serialized);
    } else {
      await this.redis.set(key, serialized);
    }
  }

  async del(key: string): Promise<void> {
    await this.redis.del(key);
  }

  async delPattern(pattern: string): Promise<void> {
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }

  // Cache with automatic refresh
  async getOrSet<T>(
    key: string, 
    factory: () => Promise<T>, 
    ttl: number = 3600
  ): Promise<T> {
    let value = await this.get<T>(key);
    
    if (value === null) {
      value = await factory();
      await this.set(key, value, ttl);
    }
    
    return value;
  }

  // Rate limiting
  async increment(key: string, ttl: number): Promise<number> {
    const current = await this.redis.incr(key);
    if (current === 1) {
      await this.redis.expire(key, ttl);
    }
    return current;
  }

  // Session management
  async setSession(sessionId: string, data: any, ttl: number = 86400): Promise<void> {
    await this.set(`session:${sessionId}`, data, ttl);
  }

  async getSession<T>(sessionId: string): Promise<T | null> {
    return this.get<T>(`session:${sessionId}`);
  }

  async deleteSession(sessionId: string): Promise<void> {
    await this.del(`session:${sessionId}`);
  }
}

// Cache interceptor for frequent queries
@Injectable()
export class CacheInterceptor implements NestInterceptor {
  constructor(private cacheService: CacheService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const cacheKey = this.generateCacheKey(request);
    const ttl = this.getTTL(request);

    if (request.method !== 'GET') {
      return next.handle();
    }

    return from(this.cacheService.get(cacheKey)).pipe(
      switchMap((cachedResponse) => {
        if (cachedResponse) {
          return of(cachedResponse);
        }

        return next.handle().pipe(
          tap((response) => {
            this.cacheService.set(cacheKey, response, ttl);
          })
        );
      })
    );
  }

  private generateCacheKey(request: any): string {
    const url = request.url;
    const userId = request.user?.sub;
    return `api:${userId || 'anonymous'}:${url}`;
  }

  private getTTL(request: any): number {
    // Different TTL for different endpoints
    const ttlMap = {
      '/projects/search': 300, // 5 minutes
      '/freelancers/search': 300,
      '/categories': 3600, // 1 hour
      '/skills': 3600,
      default: 600 // 10 minutes
    };

    const path = request.route?.path;
    return ttlMap[path] || ttlMap.default;
  }
}
```

### Database Optimization
```typescript
// database/indexes.ts
export const createIndexes = async (db: Db) => {
  // User indexes
  await db.collection('users').createIndexes([
    { key: { email: 1 }, unique: true },
    { key: { username: 1 }, unique: true },
    { key: { 'profile.location.coordinates': '2dsphere' } },
    { key: { status: 1, createdAt: -1 } }
  ]);

  // Project indexes
  await db.collection('projects').createIndexes([
    { key: { title: 'text', description: 'text' } },
    { key: { status: 1, visibility: 1, createdAt: -1 } },
    { key: { category: 1, status: 1 } },
    { key: { requiredSkills: 1, status: 1 } },
    { key: { clientId: 1, status: 1 } },
    { key: { 'budget.amount': 1, status: 1 } },
    { key: { createdAt: -1 } }
  ]);

  // FreelancerProfile indexes
  await db.collection('freelancerprofiles').createIndexes([
    { key: { userId: 1 }, unique: true },
    { key: { 'skills.primary': 1, 'professional.availability': 1 } },
    { key: { 'skills.categories': 1 } },
    { key: { 'stats.averageRating': -1, 'stats.totalReviews': -1 } },
    { key: { 'visibility.searchable': 1, 'professional.availability': 1 } }
  ]);

  // Contract indexes
  await db.collection('contracts').createIndexes([
    { key: { projectId: 1 }, unique: true },
    { key: { clientId: 1, status: 1 } },
    { key: { freelancerId: 1, status: 1 } },
    { key: { status: 1, createdAt: -1 } }
  ]);

  // Message indexes
  await db.collection('messages').createIndexes([
    { key: { conversationId: 1, createdAt: -1 } },
    { key: { senderId: 1, receiverId: 1 } },
    { key: { receiverId: 1, isRead: 1 } }
  ]);

  // Payment indexes
  await db.collection('payments').createIndexes([
    { key: { contractId: 1, type: 1 } },
    { key: { stripePaymentIntentId: 1 }, unique: true },
    { key: { status: 1, createdAt: -1 } }
  ]);

  // Notification indexes
  await db.collection('notifications').createIndexes([
    { key: { userId: 1, isRead: 1, createdAt: -1 } },
    { key: { createdAt: 1 }, expireAfterSeconds: 2592000 } // 30 days
  ]);
};

// Query optimization service
@Injectable()
export class QueryOptimizationService {
  // Optimized project search with aggregation
  async searchProjectsOptimized(params: SearchProjectsDto): Promise<any> {
    const pipeline = [];

    // Initial match stage
    const matchStage: any = {
      status: 'open',
      visibility: 'public'
    };

    if (params.category) {
      matchStage.category = params.category;
    }

    if (params.skills?.length > 0) {
      matchStage.requiredSkills = { $in: params.skills };
    }

    pipeline.push({ $match: matchStage });

    // Text search stage (if needed)
    if (params.query) {
      pipeline.unshift({
        $match: { $text: { $search: params.query } }
      });
      pipeline.push({
        $addFields: { score: { $meta: 'textScore' } }
      });
    }

    // Lookup client info in single stage
    pipeline.push({
      $lookup: {
        from: 'users',
        let: { clientId: '$clientId' },
        pipeline: [
          { $match: { $expr: { $eq: ['$_id', '$clientId'] } } },
          { $project: { profile: 1, verification: 1 } }
        ],
        as: 'clientInfo'
      }
    });

    // Add computed fields
    pipeline.push({
      $addFields: {
        clientInfo: { $arrayElemAt: ['$clientInfo', 0] },
        proposalCount: { $size: '$proposals.received' },
        competitionLevel: {
          $switch: {
            branches: [
              { case: { $lt: [{ $size: '$proposals.received' }, 5] }, then: 'low' },
              { case: { $lt: [{ $size: '$proposals.received' }, 15] }, then: 'medium' }
            ],
            default: 'high'
          }
        }
      }
    });

    // Sorting
    const sortStage: any = {};
    if (params.query && !params.sort) {
      sortStage.score = { $meta: 'textScore' };
    } else {
      switch (params.sort) {
        case 'newest':
          sortStage.createdAt = -1;
          break;
        case 'budget_high':
          sortStage['budget.amount'] = -1;
          break;
        case 'budget_low':
          sortStage['budget.amount'] = 1;
          break;
        default:
          sortStage.createdAt = -1;
      }
    }
    pipeline.push({ $sort: sortStage });

    // Pagination
    pipeline.push({ $skip: (params.page - 1) * params.limit });
    pipeline.push({ $limit: params.limit });

    return pipeline;
  }
}
```

## Background Jobs and Queues

### Job Processing System
```typescript
// jobs/queue.service.ts
import { Injectable } from '@nestjs/common';
import { Queue, Worker, Job } from 'bullmq';
import { Redis } from 'ioredis';

@Injectable()
export class QueueService {
  private emailQueue: Queue;
  private paymentQueue: Queue;
  private notificationQueue: Queue;
  private analyticsQueue: Queue;

  constructor(private redis: Redis) {
    this.emailQueue = new Queue('email', { connection: redis });
    this.paymentQueue = new Queue('payment', { connection: redis });
    this.notificationQueue = new Queue('notification', { connection: redis });
    this.analyticsQueue = new Queue('analytics', { connection: redis });

    this.initializeWorkers();
  }

  // Email jobs
  async sendWelcomeEmail(userId: string, email: string) {
    return this.emailQueue.add('welcome-email', 
      { userId, email },
      { delay: 1000, attempts: 3 }
    );
  }

  async sendProjectNotification(freelancerIds: string[], projectId: string) {
    return this.emailQueue.add('project-notification',
      { freelancerIds, projectId },
      { attempts: 3, backoff: { type: 'exponential', delay: 5000 } }
    );
  }

  // Payment processing jobs
  async processPaymentRelease(contractId: string, milestoneIndex: number) {
    return this.paymentQueue.add('release-payment',
      { contractId, milestoneIndex },
      { 
        attempts: 5,
        backoff: { type: 'exponential', delay: 10000 },
        removeOnComplete: 100,
        removeOnFail: 50
      }
    );
  }

  // Notification jobs
  async sendPushNotification(userId: string, notification: any) {
    return this.notificationQueue.add('push-notification',
      { userId, notification },
      { attempts: 3 }
    );
  }

  // Analytics jobs
  async updateUserStats(userId: string, action: string, metadata: any) {
    return this.analyticsQueue.add('update-stats',
      { userId, action, metadata },
      { delay: 60000 } // Process after 1 minute
    );
  }

  private initializeWorkers() {
    // Email worker
    new Worker('email', async (job: Job) => {
      switch (job.name) {
        case 'welcome-email':
          return this.processWelcomeEmail(job.data);
        case 'project-notification':
          return this.processProjectNotification(job.data);
        default:
          throw new Error(`Unknown email job: ${job.name}`);
      }
    }, { connection: this.redis, concurrency: 5 });

    // Payment worker
    new Worker('payment', async (job: Job) => {
      switch (job.name) {
        case 'release-payment':
          return this.processPaymentRelease(job.data);
        default:
          throw new Error(`Unknown payment job: ${job.name}`);
      }
    }, { connection: this.redis, concurrency: 3 });

    // Notification worker
    new Worker('notification', async (job: Job) => {
      switch (job.name) {
        case 'push-notification':
          return this.processPushNotification(job.data);
        default:
          throw new Error(`Unknown notification job: ${job.name}`);
      }
    }, { connection: this.redis, concurrency: 10 });

    // Analytics worker
    new Worker('analytics', async (job: Job) => {
      switch (job.name) {
        case 'update-stats':
          return this.processStatsUpdate(job.data);
        default:
          throw new Error(`Unknown analytics job: ${job.name}`);
      }
    }, { connection: this.redis, concurrency: 2 });
  }

  private async processWelcomeEmail(data: any) {
    // Implementation for welcome email
    console.log(`Sending welcome email to ${data.email}`);
  }

  private async processProjectNotification(data: any) {
    // Implementation for project notifications
    console.log(`Notifying ${data.freelancerIds.length} freelancers about project ${data.projectId}`);
  }

  private async processPaymentRelease(data: any) {
    // Implementation for payment release
    console.log(`Releasing payment for contract ${data.contractId}, milestone ${data.milestoneIndex}`);
  }

  private async processPushNotification(data: any) {
    // Implementation for push notifications
    console.log(`Sending push notification to user ${data.userId}`);
  }

  private async processStatsUpdate(data: any) {
    // Implementation for stats update
    console.log(`Updating stats for user ${data.userId}: ${data.action}`);
  }
}
```

## API Documentation Generation

### Swagger Configuration
```typescript
// main.ts - Swagger setup
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Swagger configuration
  const config = new DocumentBuilder()
    .setTitle('FreelanceHub API')
    .setDescription('Complete API documentation for FreelanceHub platform')
    .setVersion('1.0')
    .addBearerAuth(
      {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT',
        name: 'JWT',
        description: 'Enter JWT token',
        in: 'header',
      },
      'JWT-auth'
    )
    .addServer('http://localhost:3000', 'Development server')
    .addServer('https://api.freelancehub.lk', 'Production server')
    .addTag('Authentication', 'User authentication and authorization')
    .addTag('Projects', 'Project management operations')
    .addTag('Proposals', 'Proposal and bidding system')
    .addTag('Contracts', 'Contract and milestone management')
    .addTag('Payments', 'Payment processing with Stripe')
    .addTag('Messages', 'Real-time messaging system')
    .addTag('Reviews', 'Review and rating system')
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api/docs', app, document, {
    swaggerOptions: {
      persistAuthorization: true,
      docExpansion: 'none',
      filter: true,
      showRequestDuration: true,
    }
  });

  await app.listen(3000);
}
```

This complete backend specification provides a production-ready foundation for FreelanceHub with comprehensive features including:

## Summary of Key Components

### Core Features
- **WebAuthn Passkey Authentication** with 2FA support
- **Stripe Payment Integration** with escrow system
- **Real-time Messaging** via WebSockets
- **Advanced Search & Recommendations** with ML-based suggestions
- **Comprehensive Review System** with fraud prevention
- **Contract & Milestone Management** with automated workflows

### Production-Ready Infrastructure
- **Robust Error Handling** with custom exception filters
- **Comprehensive Logging** with structured business event tracking  
- **Performance Monitoring** with Prometheus metrics
- **Advanced Caching** with Redis integration
- **Background Job Processing** with BullMQ
- **Database Optimization** with proper indexing strategies

### Security & Compliance
- **Multi-layer Security** with rate limiting and input sanitization
- **Payment Security** following PCI DSS guidelines
- **Data Protection** with encryption and access controls
- **Audit Logging** for compliance and security monitoring

### Testing & Quality Assurance
- **Comprehensive Test Suite** with unit and integration tests
- **API Documentation** with Swagger/OpenAPI
- **Performance Testing** capabilities
- **Code Quality** standards with validation and type safety

This specification provides everything needed to build a scalable, secure, and maintainable freelance platform backend that can handle real-world production loads and requirements.start')